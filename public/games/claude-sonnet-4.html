<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brick Breaker</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      font-family: 'Arial', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      color: white;
    }

    .game-container {
      text-align: center;
      padding: 20px;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      background: linear-gradient(45deg, #ff6b6b, #ffd93d);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .game-info {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
      font-size: 1.2rem;
      font-weight: bold;
    }

    canvas {
      border: 4px solid #fff;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      background: #000;
    }

    .controls {
      margin-top: 20px;
      font-size: 1rem;
      opacity: 0.8;
    }

    .game-over,
    .game-won {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      padding: 40px;
      border-radius: 15px;
      text-align: center;
      z-index: 1000;
      display: none;
    }

    .game-over h2,
    .game-won h2 {
      font-size: 2rem;
      margin-bottom: 20px;
      color: #ff6b6b;
    }

    .game-won h2 {
      color: #4ecdc4;
    }

    button {
      background: linear-gradient(45deg, #ff6b6b, #ffd93d);
      border: none;
      padding: 12px 24px;
      font-size: 1rem;
      font-weight: bold;
      color: white;
      border-radius: 25px;
      cursor: pointer;
      transition: transform 0.2s;
      margin-top: 15px;
    }

    button:hover {
      transform: scale(1.05);
    }

    .particle {
      position: absolute;
      pointer-events: none;
      border-radius: 50%;
    }
  </style>
</head>

<body>
  <div class="game-container">
    <h1>ðŸ§± BRICK BREAKER ðŸ§±</h1>

    <div class="game-info">
      <div>Score: <span id="score">0</span></div>
      <div>Level: <span id="level">1</span></div>
      <div>Lives: <span id="lives">3</span></div>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div class="controls">
      Use arrow keys or mouse to move the paddle â€¢ Press SPACE to start/pause
    </div>

    <div class="game-over" id="gameOver">
      <h2>Game Over!</h2>
      <p>Final Score: <span id="finalScore">0</span></p>
      <button onclick="restartGame()">Play Again</button>
    </div>

    <div class="game-won" id="gameWon">
      <h2>Congratulations!</h2>
      <p>You cleared all levels!</p>
      <p>Final Score: <span id="winScore">0</span></p>
      <button onclick="restartGame()">Play Again</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Game state
    let gameState = {
      score: 0,
      level: 1,
      lives: 3,
      gameRunning: false,
      gameStarted: false
    };

    // Paddle
    const paddle = {
      width: 120,
      height: 15,
      x: canvas.width / 2 - 60,
      y: canvas.height - 40,
      speed: 8,
      dx: 0
    };

    // Ball
    const ball = {
      x: canvas.width / 2,
      y: canvas.height - 60,
      radius: 8,
      dx: 0,
      dy: 0,
      speed: 6,
      onPaddle: true
    };

    // Bricks
    let bricks = [];
    const brickRowCount = 6;
    const brickColumnCount = 10;
    const brickWidth = 70;
    const brickHeight = 25;
    const brickPadding = 5;
    const brickOffsetTop = 80;
    const brickOffsetLeft = 35;

    // Particles for effects
    let particles = [];

    // Colors for different brick rows
    const brickColors = ['#ff6b6b', '#ffd93d', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];

    function createBricks() {
      bricks = [];
      for (let r = 0; r < brickRowCount; r++) {
        bricks[r] = [];
        for (let c = 0; c < brickColumnCount; c++) {
          bricks[r][c] = {
            x: c * (brickWidth + brickPadding) + brickOffsetLeft,
            y: r * (brickHeight + brickPadding) + brickOffsetTop,
            status: 1,
            color: brickColors[r % brickColors.length],
            points: (brickRowCount - r) * 10
          };
        }
      }
    }

    function drawBricks() {
      for (let r = 0; r < brickRowCount; r++) {
        for (let c = 0; c < brickColumnCount; c++) {
          if (bricks[r][c].status === 1) {
            const brick = bricks[r][c];

            // Create gradient effect
            const gradient = ctx.createLinearGradient(brick.x, brick.y, brick.x, brick.y + brickHeight);
            gradient.addColorStop(0, brick.color);
            gradient.addColorStop(1, adjustBrightness(brick.color, -20));

            ctx.fillStyle = gradient;
            ctx.fillRect(brick.x, brick.y, brickWidth, brickHeight);

            // Add border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.strokeRect(brick.x, brick.y, brickWidth, brickHeight);
          }
        }
      }
    }

    function drawPaddle() {
      // Create gradient for paddle
      const gradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
      gradient.addColorStop(0, '#fff');
      gradient.addColorStop(1, '#ddd');

      ctx.fillStyle = gradient;
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

      // Add rounded corners effect
      ctx.strokeStyle = '#bbb';
      ctx.lineWidth = 2;
      ctx.strokeRect(paddle.x, paddle.y, paddle.width, paddle.height);
    }

    function drawBall() {
      // Create radial gradient for ball
      const gradient = ctx.createRadialGradient(ball.x - 2, ball.y - 2, 0, ball.x, ball.y, ball.radius);
      gradient.addColorStop(0, '#fff');
      gradient.addColorStop(1, '#ff6b6b');

      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.closePath();
    }

    function drawParticles() {
      particles.forEach((particle, index) => {
        ctx.save();
        ctx.globalAlpha = particle.alpha;
        ctx.fillStyle = particle.color;
        ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
        ctx.restore();

        // Update particle
        particle.x += particle.dx;
        particle.y += particle.dy;
        particle.alpha -= 0.02;
        particle.size *= 0.98;

        // Remove dead particles
        if (particle.alpha <= 0 || particle.size <= 0) {
          particles.splice(index, 1);
        }
      });
    }

    function createParticles(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x,
          y: y,
          dx: (Math.random() - 0.5) * 6,
          dy: (Math.random() - 0.5) * 6,
          color: color,
          alpha: 1,
          size: Math.random() * 4 + 2
        });
      }
    }

    function adjustBrightness(color, amount) {
      const num = parseInt(color.replace("#", ""), 16);
      const amt = Math.round(2.55 * amount);
      const R = (num >> 16) + amt;
      const G = (num >> 8 & 0x00FF) + amt;
      const B = (num & 0x0000FF) + amt;
      return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
        (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }

    function collisionDetection() {
      for (let r = 0; r < brickRowCount; r++) {
        for (let c = 0; c < brickColumnCount; c++) {
          const brick = bricks[r][c];
          if (brick.status === 1) {
            if (ball.x + ball.radius > brick.x &&
              ball.x - ball.radius < brick.x + brickWidth &&
              ball.y + ball.radius > brick.y &&
              ball.y - ball.radius < brick.y + brickHeight) {

              ball.dy = -ball.dy;
              brick.status = 0;

              // Add score
              gameState.score += brick.points;
              updateScore();

              // Create particles
              createParticles(brick.x + brickWidth / 2, brick.y + brickHeight / 2, brick.color);

              // Check if all bricks are destroyed
              if (gameState.score === getTotalBrickPoints()) {
                nextLevel();
                return;
              }
            }
          }
        }
      }
    }

    function getTotalBrickPoints() {
      let total = 0;
      for (let r = 0; r < brickRowCount; r++) {
        for (let c = 0; c < brickColumnCount; c++) {
          total += (brickRowCount - r) * 10;
        }
      }
      return total * gameState.level;
    }

    function nextLevel() {
      gameState.level++;
      ball.speed += 0.5;
      resetBallAndPaddle();
      createBricks();

      if (gameState.level > 3) {
        // Game won!
        gameState.gameRunning = false;
        document.getElementById('winScore').textContent = gameState.score;
        document.getElementById('gameWon').style.display = 'block';
      }
    }

    function resetBallAndPaddle() {
      paddle.x = canvas.width / 2 - paddle.width / 2;
      ball.x = canvas.width / 2;
      ball.y = canvas.height - 60;
      ball.dx = 0;
      ball.dy = 0;
      ball.onPaddle = true;
    }

    function movePaddle() {
      paddle.x += paddle.dx;

      // Keep paddle within canvas
      if (paddle.x < 0) paddle.x = 0;
      if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;

      // Move ball with paddle when on paddle
      if (ball.onPaddle) {
        ball.x = paddle.x + paddle.width / 2;
      }
    }

    function moveBall() {
      if (ball.onPaddle) return;

      ball.x += ball.dx;
      ball.y += ball.dy;

      // Ball collision with walls
      if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
        ball.dx = -ball.dx;
      }

      if (ball.y - ball.radius < 0) {
        ball.dy = -ball.dy;
      }

      // Ball collision with paddle
      if (ball.y + ball.radius > paddle.y &&
        ball.x > paddle.x &&
        ball.x < paddle.x + paddle.width) {

        // Calculate bounce angle based on where ball hits paddle
        let hitPos = (ball.x - paddle.x) / paddle.width;
        ball.dx = ball.speed * (hitPos - 0.5) * 2;
        ball.dy = -Math.abs(ball.dy);
      }

      // Ball goes out of bounds
      if (ball.y + ball.radius > canvas.height) {
        gameState.lives--;
        updateLives();

        if (gameState.lives <= 0) {
          // Game over
          gameState.gameRunning = false;
          document.getElementById('finalScore').textContent = gameState.score;
          document.getElementById('gameOver').style.display = 'block';
        } else {
          resetBallAndPaddle();
        }
      }
    }

    function launchBall() {
      if (ball.onPaddle) {
        ball.onPaddle = false;
        ball.dx = (Math.random() - 0.5) * ball.speed;
        ball.dy = -ball.speed;
        gameState.gameRunning = true;
      }
    }

    function updateScore() {
      document.getElementById('score').textContent = gameState.score;
    }

    function updateLevel() {
      document.getElementById('level').textContent = gameState.level;
    }

    function updateLives() {
      document.getElementById('lives').textContent = gameState.lives;
    }

    function draw() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw game elements
      drawBricks();
      drawPaddle();
      drawBall();
      drawParticles();

      // Show start message
      if (!gameState.gameStarted) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Press SPACE to start!', canvas.width / 2, canvas.height / 2);
      }
    }

    function gameLoop() {
      if (gameState.gameRunning) {
        movePaddle();
        moveBall();
        collisionDetection();
      }

      draw();
      requestAnimationFrame(gameLoop);
    }

    function restartGame() {
      gameState = {
        score: 0,
        level: 1,
        lives: 3,
        gameRunning: false,
        gameStarted: false
      };

      ball.speed = 6;
      particles = [];

      updateScore();
      updateLevel();
      updateLives();

      resetBallAndPaddle();
      createBricks();

      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('gameWon').style.display = 'none';
    }

    // Event listeners
    document.addEventListener('keydown', function (e) {
      if (e.code === 'ArrowLeft') {
        paddle.dx = -paddle.speed;
      } else if (e.code === 'ArrowRight') {
        paddle.dx = paddle.speed;
      } else if (e.code === 'Space') {
        e.preventDefault();
        if (!gameState.gameStarted) {
          gameState.gameStarted = true;
          launchBall();
        } else if (ball.onPaddle) {
          launchBall();
        }
      }
    });

    document.addEventListener('keyup', function (e) {
      if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
        paddle.dx = 0;
      }
    });

    // Mouse controls
    canvas.addEventListener('mousemove', function (e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      paddle.x = mouseX - paddle.width / 2;

      // Keep paddle within bounds
      if (paddle.x < 0) paddle.x = 0;
      if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;

      if (ball.onPaddle) {
        ball.x = paddle.x + paddle.width / 2;
      }
    });

    canvas.addEventListener('click', function () {
      if (!gameState.gameStarted) {
        gameState.gameStarted = true;
        launchBall();
      } else if (ball.onPaddle) {
        launchBall();
      }
    });

    // Initialize game
    createBricks();
    gameLoop();
  </script>
</body>

</html>