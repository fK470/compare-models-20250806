<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brick Breaker Game</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #222;
      font-family: Arial, sans-serif;
    }

    #game-container {
      position: relative;
    }

    #game-canvas {
      background-color: #111;
      border: 2px solid #444;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    #start-screen,
    #game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
    }

    #game-over-screen {
      display: none;
    }

    h1 {
      font-size: 36px;
      margin-bottom: 20px;
      color: #ff6b6b;
    }

    button {
      padding: 10px 20px;
      font-size: 18px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #45a049;
    }

    #score-display {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 18px;
    }

    #lives-display {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      font-size: 18px;
    }
  </style>
</head>

<body>
  <div id="game-container">
    <canvas id="game-canvas" width="800" height="600"></canvas>

    <div id="score-display">Score: 0</div>
    <div id="lives-display">Lives: 3</div>

    <div id="start-screen">
      <h1>Brick Breaker</h1>
      <button id="start-button">Start Game</button>
    </div>

    <div id="game-over-screen">
      <h1>Game Over</h1>
      <p id="final-score">Final Score: 0</p>
      <button id="restart-button">Play Again</button>
    </div>
  </div>

  <script>
    // Game elements
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const scoreDisplay = document.getElementById('score-display');
    const livesDisplay = document.getElementById('lives-display');
    const finalScoreDisplay = document.getElementById('final-score');

    // Game variables
    let score = 0;
    let lives = 3;
    let gameRunning = false;
    let animationId;

    // Paddle properties
    const paddleWidth = 100;
    const paddleHeight = 15;
    const paddleSpeed = 8;
    let paddleX = (canvas.width - paddleWidth) / 2;

    // Ball properties
    const ballRadius = 10;
    let ballX = canvas.width / 2;
    let ballY = canvas.height - 30;
    let ballSpeedX = 5;
    let ballSpeedY = -5;

    // Brick properties
    const brickRowCount = 5;
    const brickColumnCount = 10;
    const brickWidth = 75;
    const brickHeight = 20;
    const brickPadding = 10;
    const brickOffsetTop = 60;
    const brickOffsetLeft = 30;
    let bricks = [];

    // Initialize bricks
    function initBricks() {
      bricks = [];
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          bricks[c][r] = { x: 0, y: 0, status: 1 };
        }
      }
    }

    // Event listeners
    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', startGame);

    document.addEventListener('keydown', keyDownHandler);
    document.addEventListener('keyup', keyUpHandler);
    canvas.addEventListener('mousemove', mouseMoveHandler);

    // Keyboard controls
    let rightPressed = false;
    let leftPressed = false;

    function keyDownHandler(e) {
      if (e.key === 'Right' || e.key === 'ArrowRight') {
        rightPressed = true;
      } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
        leftPressed = true;
      }
    }

    function keyUpHandler(e) {
      if (e.key === 'Right' || e.key === 'ArrowRight') {
        rightPressed = false;
      } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
        leftPressed = false;
      }
    }

    // Mouse controls
    function mouseMoveHandler(e) {
      if (!gameRunning) return;

      const relativeX = e.clientX - canvas.offsetLeft;
      if (relativeX > paddleWidth / 2 && relativeX < canvas.width - paddleWidth / 2) {
        paddleX = relativeX - paddleWidth / 2;
      }
    }

    // Collision detection
    function collisionDetection() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const brick = bricks[c][r];
          if (brick.status === 1) {
            if (
              ballX > brick.x &&
              ballX < brick.x + brickWidth &&
              ballY > brick.y &&
              ballY < brick.y + brickHeight
            ) {
              ballSpeedY = -ballSpeedY;
              brick.status = 0;
              score++;
              updateScore();

              // Check if all bricks are broken
              if (score === brickRowCount * brickColumnCount) {
                gameOver(true);
              }
            }
          }
        }
      }
    }

    // Update score display
    function updateScore() {
      scoreDisplay.textContent = `Score: ${score}`;
    }

    // Update lives display
    function updateLives() {
      livesDisplay.textContent = `Lives: ${lives}`;
    }

    // Draw paddle
    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
      ctx.fillStyle = '#4CAF50';
      ctx.fill();
      ctx.closePath();
    }

    // Draw ball
    function drawBall() {
      ctx.beginPath();
      ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
      ctx.fillStyle = '#ff6b6b';
      ctx.fill();
      ctx.closePath();
    }

    // Draw bricks
    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status === 1) {
            const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
            const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;

            ctx.beginPath();
            ctx.rect(brickX, brickY, brickWidth, brickHeight);
            ctx.fillStyle = '#0095DD';
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }

    // Main game loop
    function draw() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw game elements
      drawBricks();
      drawPaddle();
      drawBall();

      // Collision detection
      collisionDetection();

      // Ball collision with walls
      if (ballX + ballSpeedX > canvas.width - ballRadius || ballX + ballSpeedX < ballRadius) {
        ballSpeedX = -ballSpeedX;
      }

      if (ballY + ballSpeedY < ballRadius) {
        ballSpeedY = -ballSpeedY;
      } else if (ballY + ballSpeedY > canvas.height - ballRadius) {
        // Ball hits bottom or paddle
        if (ballX > paddleX && ballX < paddleX + paddleWidth) {
          // Calculate bounce angle based on where ball hits paddle
          const hitPosition = (ballX - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
          const angle = hitPosition * Math.PI / 3; // Max 60 degrees

          // Calculate new speed based on angle
          const speed = Math.sqrt(ballSpeedX * ballSpeedX + ballSpeedY * ballSpeedY);
          ballSpeedX = speed * Math.sin(angle);
          ballSpeedY = -speed * Math.cos(angle);
        } else {
          // Ball hits bottom - lose a life
          lives--;
          updateLives();

          if (lives <= 0) {
            gameOver(false);
          } else {
            // Reset ball position
            ballX = canvas.width / 2;
            ballY = canvas.height - 30;
            ballSpeedX = 5;
            ballSpeedY = -5;
            paddleX = (canvas.width - paddleWidth) / 2;
          }
        }
      }

      // Paddle movement
      if (rightPressed && paddleX < canvas.width - paddleWidth) {
        paddleX += paddleSpeed;
      } else if (leftPressed && paddleX > 0) {
        paddleX -= paddleSpeed;
      }

      // Move ball
      ballX += ballSpeedX;
      ballY += ballSpeedY;

      // Continue animation
      if (gameRunning) {
        animationId = requestAnimationFrame(draw);
      }
    }

    // Start game
    function startGame() {
      score = 0;
      lives = 3;
      ballX = canvas.width / 2;
      ballY = canvas.height - 30;
      ballSpeedX = 5;
      ballSpeedY = -5;
      paddleX = (canvas.width - paddleWidth) / 2;

      initBricks();
      updateScore();
      updateLives();

      startScreen.style.display = 'none';
      gameOverScreen.style.display = 'none';
      gameRunning = true;

      draw();
    }

    // Game over
    function gameOver(win) {
      gameRunning = false;
      cancelAnimationFrame(animationId);

      finalScoreDisplay.textContent = `Final Score: ${score}`;
      gameOverScreen.querySelector('h1').textContent = win ? 'You Win!' : 'Game Over';
      gameOverScreen.style.display = 'flex';
    }
  </script>
</body>

</html>