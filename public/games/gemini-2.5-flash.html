<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brick Breaker Game</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      background-color: #2c3e50;
      /* Dark blue-gray background */
      font-family: 'Press Start 2P', cursive;
      /* Retro game font */
      color: #ecf0f1;
      /* Light gray text */
      flex-direction: column;
      overflow: hidden;
      /* Prevent scrollbars */
    }

    /* Import Google Font for game-like text */
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    h1 {
      color: #f1c40f;
      /* Yellow title */
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    canvas {
      background-color: #34495e;
      /* Slightly lighter blue-gray for canvas */
      display: block;
      border: 5px solid #f1c40f;
      /* Yellow border */
      border-radius: 15px;
      /* Rounded corners for the game area */
      box-shadow: 0 0 20px rgba(241, 196, 15, 0.7);
      /* Glow effect */
      touch-action: none;
      /* Prevent default touch actions like scrolling/zooming */
    }

    .game-info {
      display: flex;
      justify-content: space-between;
      width: 800px;
      /* Match canvas width */
      margin-top: 10px;
      font-size: 1.2em;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }

    .game-info div {
      padding: 5px 10px;
      background-color: #2980b9;
      /* Blue background for info boxes */
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }

    .controls {
      margin-top: 20px;
      display: flex;
      gap: 15px;
    }

    .button {
      background-color: #e74c3c;
      /* Red button */
      color: white;
      padding: 12px 25px;
      border: none;
      border-radius: 10px;
      font-family: 'Press Start 2P', cursive;
      font-size: 1em;
      cursor: pointer;
      box-shadow: 0 5px 0 #c0392b;
      /* Darker red shadow */
      transition: all 0.1s ease;
      text-transform: uppercase;
    }

    .button:hover {
      background-color: #c0392b;
      box-shadow: 0 3px 0 #a52a22;
      transform: translateY(2px);
    }

    .button:active {
      background-color: #a52a22;
      box-shadow: 0 0 0 #a52a22;
      transform: translateY(5px);
    }

    .button.start {
      background-color: #27ae60;
      /* Green start button */
      box-shadow: 0 5px 0 #229a54;
    }

    .button.start:hover {
      background-color: #229a54;
      box-shadow: 0 3px 0 #1e8449;
    }

    .button.start:active {
      background-color: #1e8449;
      box-shadow: 0 0 0 #1e8449;
    }

    /* Game Over/Win Message Styling */
    .game-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      padding: 30px 50px;
      border-radius: 15px;
      border: 3px solid #f1c40f;
      text-align: center;
      font-size: 2em;
      font-weight: bold;
      color: #f1c40f;
      z-index: 100;
      display: none;
      /* Hidden by default */
      box-shadow: 0 0 30px rgba(241, 196, 15, 0.9);
      animation: pulse 1.5s infinite alternate;
    }

    @keyframes pulse {
      from {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }

      to {
        transform: translate(-50%, -50%) scale(1.05);
        opacity: 0.9;
      }
    }

    .game-message button {
      margin-top: 20px;
      padding: 15px 30px;
      font-size: 1.2em;
    }
  </style>
</head>

<body>
  <h1>ブロック崩しゲーム</h1>
  <div class="game-info">
    <div id="scoreDisplay">スコア: 0</div>
    <div id="livesDisplay">ライフ: 3</div>
  </div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div class="controls">
    <button id="startButton" class="button start">ゲーム開始</button>
    <button id="resetButton" class="button">リセット</button>
  </div>

  <div id="gameMessage" class="game-message">
    <p id="messageText"></p>
    <button id="restartButton" class="button start">もう一度プレイ</button>
  </div>

  <script>
    // Get the canvas element and its 2D rendering context
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Get score and lives display elements
    const scoreDisplay = document.getElementById('scoreDisplay');
    const livesDisplay = document.getElementById('livesDisplay');
    const startButton = document.getElementById('startButton');
    const resetButton = document.getElementById('resetButton');
    const gameMessage = document.getElementById('gameMessage');
    const messageText = document.getElementById('messageText');
    const restartButton = document.getElementById('restartButton');

    // Game variables
    let score = 0;
    let lives = 3;
    let gameRunning = false;
    let animationFrameId; // To store the requestAnimationFrame ID

    // Ball properties
    const ballRadius = 10;
    let x = canvas.width / 2; // Ball's x-coordinate
    let y = canvas.height - 30; // Ball's y-coordinate
    let dx = 4; // Ball's x-direction speed
    let dy = -4; // Ball's y-direction speed

    // Paddle properties
    const paddleHeight = 15;
    const paddleWidth = 100;
    let paddleX = (canvas.width - paddleWidth) / 2; // Paddle's x-coordinate

    // Keyboard controls for paddle
    let rightPressed = false;
    let leftPressed = false;

    // Brick properties
    const brickRowCount = 5;
    const brickColumnCount = 8;
    const brickWidth = 80;
    const brickHeight = 20;
    const brickPadding = 10;
    const brickOffsetTop = 30;
    const brickOffsetLeft = 30;

    // Array to store bricks
    let bricks = [];

    // Function to initialize bricks
    function initBricks() {
      bricks = []; // Clear existing bricks
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          // Each brick has an x, y position and a status (1 = active, 0 = broken)
          bricks[c][r] = { x: 0, y: 0, status: 1 };
        }
      }
    }

    // Event listeners for keyboard input
    document.addEventListener('keydown', keyDownHandler, false);
    document.addEventListener('keyup', keyUpHandler, false);

    // Event listeners for touch input (for mobile responsiveness)
    canvas.addEventListener('touchstart', touchStartHandler, false);
    canvas.addEventListener('touchmove', touchMoveHandler, false);
    canvas.addEventListener('touchend', touchEndHandler, false);

    // Keyboard handlers
    function keyDownHandler(e) {
      if (e.key === 'Right' || e.key === 'ArrowRight') {
        rightPressed = true;
      } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
        leftPressed = true;
      }
    }

    function keyUpHandler(e) {
      if (e.key === 'Right' || e.key === 'ArrowRight') {
        rightPressed = false;
      } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
        leftPressed = false;
      }
    }

    // Touch handlers
    let touchX = null; // To track initial touch position

    function touchStartHandler(e) {
      // Prevent default scrolling/zooming
      e.preventDefault();
      if (e.touches.length === 1) {
        touchX = e.touches[0].clientX;
      }
    }

    function touchMoveHandler(e) {
      e.preventDefault();
      if (e.touches.length === 1 && touchX !== null) {
        const currentTouchX = e.touches[0].clientX;
        const deltaX = currentTouchX - touchX;

        // Move paddle based on touch delta
        paddleX += deltaX * 1.5; // Multiplier for faster movement

        // Keep paddle within canvas bounds
        if (paddleX < 0) {
          paddleX = 0;
        } else if (paddleX + paddleWidth > canvas.width) {
          paddleX = canvas.width - paddleWidth;
        }
        touchX = currentTouchX; // Update touchX for next move
      }
    }

    function touchEndHandler(e) {
      e.preventDefault();
      touchX = null; // Reset touch tracking
    }

    // Function to draw the ball
    function drawBall() {
      ctx.beginPath();
      ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
      ctx.fillStyle = '#e67e22'; // Orange ball
      ctx.fill();
      ctx.closePath();
    }

    // Function to draw the paddle
    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
      ctx.fillStyle = '#3498db'; // Blue paddle
      ctx.fill();
      ctx.closePath();
    }

    // Function to draw the bricks
    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status === 1) { // Only draw active bricks
            const brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
            const brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;
            ctx.beginPath();
            ctx.rect(brickX, brickY, brickWidth, brickHeight);
            // Dynamic brick color based on row
            const hue = (r / brickRowCount) * 360; // Vary hue across rows
            ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }

    // Function to detect ball-brick collisions
    function collisionDetection() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const b = bricks[c][r];
          if (b.status === 1) { // Check only active bricks
            if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
              dy = -dy; // Reverse ball direction
              b.status = 0; // Mark brick as broken
              score++; // Increase score
              scoreDisplay.textContent = `スコア: ${score}`;

              // Check for win condition
              if (score === brickRowCount * brickColumnCount) {
                showGameMessage('おめでとうございます！すべてのブロックを破壊しました！');
                gameRunning = false;
                cancelAnimationFrame(animationFrameId);
              }
            }
          }
        }
      }
    }

    // Function to update game state and draw everything
    function draw() {
      // Clear the canvas on each frame
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawBricks();
      drawBall();
      drawPaddle();
      collisionDetection();

      // Ball movement
      x += dx;
      y += dy;

      // Ball collision with walls
      if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
        dx = -dx; // Reverse x direction
      }
      if (y + dy < ballRadius) {
        dy = -dy; // Reverse y direction (top wall)
      } else if (y + dy > canvas.height - ballRadius) {
        // Ball hits bottom edge (missed paddle)
        if (x > paddleX && x < paddleX + paddleWidth) {
          // Ball hits paddle
          dy = -dy; // Reverse y direction
          // Add a slight horizontal change based on where it hit the paddle
          const hitPoint = x - (paddleX + paddleWidth / 2);
          dx = hitPoint * 0.1; // Adjust sensitivity
        } else {
          // Ball hits bottom, lose a life
          lives--;
          livesDisplay.textContent = `ライフ: ${lives}`;
          if (lives === 0) {
            showGameMessage('ゲームオーバー！ライフがなくなりました。');
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
          } else {
            // Reset ball and paddle position for next life
            x = canvas.width / 2;
            y = canvas.height - 30;
            dx = 4;
            dy = -4;
            paddleX = (canvas.width - paddleWidth) / 2;
          }
        }
      }

      // Paddle movement based on key presses
      if (rightPressed && paddleX < canvas.width - paddleWidth) {
        paddleX += 7;
      } else if (leftPressed && paddleX > 0) {
        paddleX -= 7;
      }

      // Continue the game loop if game is running
      if (gameRunning) {
        animationFrameId = requestAnimationFrame(draw);
      }
    }

    // Function to show game over/win message
    function showGameMessage(message) {
      messageText.textContent = message;
      gameMessage.style.display = 'block';
    }

    // Function to hide game message
    function hideGameMessage() {
      gameMessage.style.display = 'none';
    }

    // Function to reset the game
    function resetGame() {
      cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
      score = 0;
      lives = 3;
      x = canvas.width / 2;
      y = canvas.height - 30;
      dx = 4;
      dy = -4;
      paddleX = (canvas.width - paddleWidth) / 2;
      rightPressed = false;
      leftPressed = false;
      scoreDisplay.textContent = `スコア: ${score}`;
      livesDisplay.textContent = `ライフ: ${lives}`;
      initBricks(); // Re-initialize all bricks
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
      drawBricks(); // Draw initial bricks
      drawBall(); // Draw initial ball
      drawPaddle(); // Draw initial paddle
      hideGameMessage(); // Hide any game messages
      gameRunning = false; // Ensure game is not running
      startButton.disabled = false; // Enable start button
    }

    // Function to start the game
    function startGame() {
      if (!gameRunning) {
        gameRunning = true;
        startButton.disabled = true; // Disable start button once game starts
        hideGameMessage(); // Hide any existing message
        draw(); // Start the game loop
      }
    }

    // Event listeners for buttons
    startButton.addEventListener('click', startGame);
    resetButton.addEventListener('click', resetGame);
    restartButton.addEventListener('click', resetGame); // Restart button also calls resetGame

    // Initialize the game when the window loads
    window.onload = function () {
      initBricks(); // Set up bricks initially
      drawBricks(); // Draw bricks on load
      drawBall(); // Draw ball on load
      drawPaddle(); // Draw paddle on load
    };
  </script>
</body>

</html>